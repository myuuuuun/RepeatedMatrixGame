# 繰り返し囚人のジレンマゲームの実験1

プログラム同士で繰り返し囚人のジレンマゲームをプレイし、どんな戦略が最も大きな利得を得られるかを実験します。  

## ルール
全てのプログラムを総当りで対戦させます。それぞれの対戦では、以下のゲームをN期にわたってプレイします。ただし、Nは全ゲームで一定とします。

<table align="center", style="text-align:center;">
  <tr>
    <th>自分の行動, 相手の行動</th>
    <th>行動0（active）</th>
    <th>行動1（inactive）</th>
  </tr>
  <tr>
    <th>行動0（active）</th>
    <td>2, 2</td>
    <td>0, 3</td>
  </tr>
  <tr>
    <th>行動1（inactive）</th>
    <td>3, 0</td>
    <td>1, 1</td>
  </tr>
</table>
  
ゲームを何期続けるかは、以下のルールによって決めます。

* 現在n期とすると、n+1期が来る確率は99.99%（n=0, 1, 2,...）  
（これは、無限回繰り返しゲームにおいて現在割引価値を0.9999と取ることを意味します）

平均は10000期になります。

全ての対戦の後、**利得の総和が最も多かったプログラムが勝ち**です。


## プログラムの仕様
第1引数に「前期までの自分の行動のリスト」、第2引数に「前期までの相手の行動のリスト」を受け取り、（その期の自分の行動として）0または1を返す関数を作成してください。

### 渡される引数:

* 現在1期目の場合
```
第1引数=[], 第2引数=[]
```
* 現在n期目の場合
```
第1引数=[第1期の自分の行動, 第2期の自分の行動, ..., 第n-1期の自分の行動],
第2引数=[第1期の相手の行動, 第2期の相手の行動, ..., 第n-1期の相手の行動]
```

### 関数の具体例:
たとえば、常に行動0（協調）をとる関数allCは以下のようになります。

```python
# 常に協調
def allC(my_history, opponent_history):
    return 0
```

tit for tatは以下のように書けます。
```python
# 相手が協調をする限りは、協調を続ける。攻撃してきたら、次の1回だけ自分も攻撃する
# 相手が直前に出した手を出すのと同じ
def tit_for_tat(my_history, opponent_history):
    if len(opponent_history) < 1:
        return 0

    return opponent_history[-1]
```

他にもいくつか関数例を用意していますので、参考にしてください。->[関数例](./sample.py)


## テスト
テストを用意しました。->[テスト](./test.py)


## 結果

[result1.txt](./result.txt)



