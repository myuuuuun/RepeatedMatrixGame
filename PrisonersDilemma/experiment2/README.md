# 繰り返し囚人のジレンマゲームの実験2

実験1と同様に、プログラム同士で繰り返し囚人のジレンマゲームをプレイし、どんな戦略が最も大きな利得を得られるかを実験します。 
今回はperfect monitoring, imperfect public monitoring, imperfect private monitoringの3パターンの実験を行います。

## ルール

### 共通ルール
全てのプログラムを総当りで、それぞれ1000回ずつ対戦させます。それぞれの対戦では、以下の利得表のstage gameをN期にわたってプレイします。ただし、Nは全ゲームで一定とします。

<table align="center", style="text-align:center;">
  <tr>
    <th>自分の行動, 相手の行動</th>
    <th>行動0（active）</th>
    <th>行動1（inactive）</th>
  </tr>
  <tr>
    <th>行動0（active）</th>
    <td>4, 4</td>
    <td>0, 5</td>
  </tr>
  <tr>
    <th>行動1（inactive）</th>
    <td>5, 0</td>
    <td>2, 2</td>
  </tr>
</table>
  
ゲームを何期続けるかは、以下のルールによって決めます。

* 現在n期とすると、**n+1期が来る確率は97%**（n=0, 1, 2,...）  
（これは、無限回繰り返しゲームにおいて現在割引価値を0.97と取ることを意味します）

平均は97期になります（第1期は確率1で来るものとします）。

全ての対戦の後、**利得の総和が最も多かったプログラムが勝ち**です。


### ゲームの履歴について

* **perfect monitoring**の場合、各期の終了時に、自分の行動と相手の行動を正確に知ることが出来ます。この履歴に基づいて、次期以降の行動を決定することが出来ます。  


* **imperfect public monitoring**の場合、プレイヤーは各期の終了時、自分の行動と相手の行動を正確に知ることは出来ず、代わりに2人の行動に基づくシグナルが公開されます。
シグナルとは、「プロジェクトの成功確率」のようなもので、{成功, 失敗}の2種類から成ります。自分と相手が(協調, 協調)をとった時にシグナルが成功になる確率が最も高く、
(攻撃, 攻撃)をとった時に成功する確率が最も低くなるように設定します。具体的には
  

成功が出る確率
<table align="center", style="text-align:center;">
  <tr>
    <th>自分の行動 / 相手の行動</th>
    <th>0</th>
    <th>1</th>
  </tr>
  <tr>
    <th>0</th>
    <td>0.9</td>
    <td>0.5</td>
  </tr>
  <tr>
    <th>1</th>
    <td>0.5</td>
    <td>0.2</td>
  </tr>
</table>

とします。したがって、シグナルから相手の実際の行動を予想し、行動を決定することになります。

* **imperfect private monitoring**の場合、プレイヤーは各期の終了時、**相手の行動に関するシグナル**を受け取ります。
このシグナルは2人の間では共有されず、各プレイヤーは相手に関するシグナルだけを見ることが出来ます。
具体的には、ある行動A = (a1, a2)がプレイされた時に発せられるシグナルは、以下の確率分布に従います。  

行: (自分が受け取る相手の行動のシグナル, 相手が受け取る自分の行動のシグナル) /  
列:(自分の実際の行動, 相手の実際の行動)
<table align="center", style="text-align:center;">
  <tr>
    <th></th>
    <th>(0, 0)</th>
    <th>(0, 1)</th>
    <th>(1, 0)</th>
    <th>(1, 1)</th>
  </tr>
  <tr>
    <th>(G, G)</th>
    <td>0.9</td>
    <td>0.02</td>
    <td>0.02</td>
    <td>0.06</td>
  </tr>
  <tr>
    <th>(G, B)</th>
    <td>0.02</td>
    <td>0.06</td>
    <td>0.9</td>
    <td>0.02</td>
  </tr>
  <tr>
    <th>(B, G)</th>
    <td>0.02</td>
    <td>0.9</td>
    <td>0.06</td>
    <td>0.02</td>
  </tr>
  <tr>
    <th>(B, B)</th>
    <td>0.06</td>
    <td>0.02</td>
    <td>0.02</td>
    <td>0.9</td>
  </tr>
</table>

例えば、実際の行動が(自分, 相手) = (0, 0)であった場合、
* 自分がシグナル0, 相手がシグナル0を正しく受け取る確率は0.9
* 自分がシグナル1, 相手がシグナル0を受け取る確率は0.02
* 自分がシグナル1, 相手がシグナル1を受け取る確率は0.06

となります。自分が相手の行動に関して誤ったシグナルを受け取った場合、相手も自分の行動に関して誤ったシグナルを受け取っている可能性が高いことに注意してください。  
( P[相手のシグナルが誤り | 自分のシグナルが誤り] = 0.06 / (0.02 + 0.06) = 3/4 )


## プログラムの仕様
戦略を表現するクラスを作成してください。  
クラスには、次の2つのメソッドを必ず含めてください（メソッド名も下の通りにしてください）。

* play(self): 各期のstage gameにおいて、行動0または1を返すメソッド
* get_signal(self, signal): 各期のstage game終了後、その期のシグナルを受け取るメソッド

### シグナルについて
perfect monitoringの場合、シグナルは相手の行動そのもの（相手の行動が0なら0, 1なら1）になります。  
imperfect public monitoringの場合、シグナルとして、プロジェクトが成功した場合0, 失敗した場合1が与えられます。シグナルは上述の確率分布に従って決定されます。  
imperfect private monitoringの場合、シグナルとして、相手の行動が0だったか1だったかが与えられます。ただし、その行動にはノイズが含まれており、
双方のシグナルは上述の同時確率分布に従って決定されます。


### クラスのテンプレート

以下のようにクラスを作成してください。例として、「基本的には協調するが、前期のシグナルがBadの場合は20%の確率で攻撃する」
ようなクラスを作成します。


```python
# テンプレート
class MyStrategy():
    def __init__(self, RandomState):
        # RandomStateオブジェクトのインスタンスを受け取る
        # 確率変数を使いたい場合は、このインスタンスを使う
        self.RandomState = RandomState
        # 自分の行動の履歴
        self.my_history = []
        # 過去の全てのシグナル
        self.signals = []


    # 各ステージゲームの実行時に呼び出されるメソッド
    # その期の行動を0（=協調）, または1（=攻撃）のいずれかから選ぶ
    def play(self):
        # 第1期は協調
        if len(self.signals) < 1:
            self.my_history.append(0)
            return 0

        # 前期のシグナル
        prior_signal = self.signals[-1]

        # 前期のシグナルがBadの時、20%の割合でこちらも攻撃する
        epsilon = self.RandomState.uniform()
        if epsilon > 0.8 and prior_signal == 1:
            self.my_history.append(1)
            return 1
        
        else:
            self.my_history.append(0)
            return 0
```

* \_\_init\_\_()では、RandomStateクラスのインスタンスを受け取ることができるようにしてください。何らかの確率分布を用いて戦略を決定する場合は、
再現性を確保するため、このインスタンスのメソッドを使用してください。RandomStateクラスで使用できる確率変数は
[NumPyのドキュメント](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html)
を参照してください。


他にもいくつか関数例を用意していますので、参考にしてください。->[関数例](./sample.py)

## テスト
テストを用意しました。->[テスト](./test.py)






